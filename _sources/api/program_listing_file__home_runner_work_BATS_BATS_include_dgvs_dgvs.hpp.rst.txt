
.. _program_listing_file__home_runner_work_BATS_BATS_include_dgvs_dgvs.hpp:

Program Listing for File dgvs.hpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_BATS_BATS_include_dgvs_dgvs.hpp>` (``/home/runner/work/BATS/BATS/include/dgvs/dgvs.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   /*
   class to store a differential graded vector space
   */
   #include <vector>
   #include <util/permutation.hpp>
   #include <filtration/update_information.hpp>
   
   namespace bats {
   
   template <typename MT>
   struct DGVectorSpace {
       int degree; // degree on the differential
       std::vector<MT> differential;
   
       MT& operator[](ssize_t k) {
           return (degree == -1) ? differential[k] : differential[k+1];
       }
       const MT& operator[](ssize_t k) const {
           return (degree == -1) ? differential[k] : differential[k+1];
       }
   
       // default to degree -1
       DGVectorSpace() : degree(-1) {}
   
       DGVectorSpace(size_t maxd, int deg=-1) : degree(deg), differential(maxd+1) {}
   
       DGVectorSpace(const std::vector<MT> &diff, int deg=-1) : degree(deg), differential(diff) {}
   
       // produce a chain complex from a simplicial or cell complex
       template <typename CpxT>
       DGVectorSpace(const CpxT& X, const int deg=-1, const bool augmented=false) : degree(deg) {
           differential.resize(X.maxdim() + 2); // extra maps for augmentation and +1 beyond
           if (degree == -1) {
               // homological type
               // first, handle augmentation
               differential[0] = augmented ? MT(1, X.ncells(0), 1) : MT(0, X.ncells(0));
               for (size_t k = 1; k < X.maxdim() + 1; k++) {
                   differential[k] = MT(X.boundary_csc(k));
               }
               // add dummy map one dimension up
               differential[X.maxdim() + 1] = MT(X.ncells(X.maxdim()), 0);
           } else if (degree == +1) {
               // cohomological type
               // first handle augmentation
               differential[0] = augmented ? MT(X.ncells(0), 1, 1) : MT(X.ncells(0), 0);
               for (size_t k = 1; k < X.maxdim() + 1; k++) {
                   differential[k] = MT(X.boundary_csc(k)).T();
               }
               // add dummy map one dimension up
               differential[X.maxdim() + 1] = MT(0, X.ncells(X.maxdim()));
           } else {
               throw std::runtime_error("Degree of DGVectorSpace should be +1 or -1");
           }
   
       }
   
   
   
       inline ssize_t maxdim() const { return differential.size()-2; }
       inline size_t dim(ssize_t k) const {
           return (this->operator[](k)).ncol();
       }
   
   };
   
   
   } // namespace bats
